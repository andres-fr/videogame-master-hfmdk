NOTES ON SC:

in https://github.com/supercollider/supercollider/blob/master/HelpSource/Classes/Group.schelp
it says that the group inherits from node, also the method basicNew, which creates the object
in the client but not in the server. And then any of this methods
newMsg, addToHeadMsg, addToTailMsg, addBeforeMsg, addAfterMsg
sent to the server like this: s.sendBundle(nil, g.<method>;);
will instantiate g on the server.


instancemethods::

subsection:: Creation without Instantiation on the Server
Use class method code::basicNew:: to create a Synth without instantiating it on the server. Then use the following instance methods:

method:: newMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group. If target is nil, it will default to the default_group of the Server specified in *basicNew when this Group was created. The default addAction is \addToHead. (See *new above for details of addActions.

method:: addToHeadMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group. If aGroup is a Group it will be added at the head of that group. If it is nil, it will be added at the head of the default_group of this Group's server (as specified when *basicNew was called).

method:: addToTailMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group. If aGroup is a Group it will be added at the tail of that group. If it is nil, it will be added at the tail of the default_group of this Group's server (as specified when *basicNew was called).

method:: addBeforeMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group, immediately before aNode.

method:: addAfterMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group, immediately after aNode.

method:: addReplaceMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group, replacing nodeToReplace in the server's node order.







TODO:




-> Player speed and final position should adapt to resizing (they are buggy).

-> use PathFinder of gdxAI to implement optimal pathfinding

-> add dorm Walkzone

-> make the Player listener ignore the click if it was on an alpha pixel (so objects that are close to the head can be
clicked anyway)

-> also important to learn how the player passes the click to other actors, in case he wants to ignore it.

-> in GameActions, screentransitions: background.clearListeners() is restored? if not, how does it still work???

-> complete bs-generator with more examples

DIRTY HACKS:

=>  keep an eye on all GameStage instances!! they should always have the omnipresent actor on them, no matter what.

=> do NOT do this: public Action ... return null; // this will generate a nullpoinerexception

=> do NOT do this BECAUSE the first action of the sequence will delete the sequence itself ):
Runnable r => run(){clearActions();}
addAction(sequence(Actions.run(r), ... ))

=> also do NOT do this BECAUSE if we want simply to queue this action,
 the first line (setState) won't be scheduled!!! it will be executed inmediately:
Action buggyMethod (int whatever){
    game.player.setState(STATES.IDLE);
    return Actions.sequence(....);
THIS IS MUCH CLEANER:
public Action WalkPlayerToAnyPoint(float x, float y) {
        Vector2 destiny = game.player.destinyStanding (x, y);
        float time = destiny.dst(game.player.getXY())/Player.SPEED;
        Runnable r1 = new Runnable() {
            @Override
            public void run() {
                game.player.setState(Player.STATES.LEFT);
            }
        };
        Runnable r2 = new Runnable() {
            @Override
            public void run() {
                game.player.setState(Player.STATES.IDLE);
            }
        };
        return Actions.sequence(Actions.run(r1), Actions.moveTo(destiny.x, destiny.y, time, Interpolation.pow2Out), Actions.run(r2));
    }



