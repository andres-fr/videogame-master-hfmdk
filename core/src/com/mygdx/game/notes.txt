TODO:


// SCALA PART:
// read this paper!
http://quod.lib.umich.edu/cgi/p/pod/dod-idx/sound-processes-a-new-computer-music-framework.pdf?c=icmc;idno=bbp2372.2014.245
// scalacollider github wiki:
https://github.com/Sciss/ScalaCollider/wiki
// scalacollider API
http://sciss.github.io/ScalaCollider/latest/api/#de.sciss.synth.package
// other files
https://github.com/Sciss/ScalaCollider/blob/master/src/main/scala/de/sciss/synth/Server.scala


// CORE:
-> Make backpack menu and head menu as a part of the Player class?
-> make the Player listener ignore the click if it was on an alpha pixel (so objects that are close to the head can be
clicked anyway)
-> also important to learn how the player passes the click to other actors, in case he wants to ignore it.
-> in GameActions, screentransitions: background.clearListeners() is restored? if not, how does it still work???

// SCENE-CONTENTS:
-> add dorm Walkzone

// NON-URGENT:
-> complete bs-generator with more examples
-> Player speed and final position should adapt to resizing (they are buggy).
-> use PathFinder of gdxAI to implement optimal pathfinding


DIRTY HACKS:

=>  keep an eye on all GameStage instances!! they should always have the omnipresent actor on them, no matter what.

=> do NOT do this: public Action ... return null; // this will generate a nullpoinerexception

=> do NOT do this BECAUSE the first action of the sequence will delete the sequence itself ):
Runnable r => run(){clearActions();}
addAction(sequence(Actions.run(r), ... ))

=> also do NOT do this BECAUSE if we want simply to queue this action,
 the first line (setState) won't be scheduled!!! it will be executed inmediately:
Action buggyMethod (int whatever){
    game.player.setState(STATES.IDLE);
    return Actions.sequence(....);
THIS IS MUCH CLEANER:
public Action WalkPlayerToAnyPoint(float x, float y) {
        Vector2 destiny = game.player.destinyStanding (x, y);
        float time = destiny.dst(game.player.getXY())/Player.SPEED;
        Runnable r1 = new Runnable() {
            @Override
            public void run() {
                game.player.setState(Player.STATES.LEFT);
            }
        };
        Runnable r2 = new Runnable() {
            @Override
            public void run() {
                game.player.setState(Player.STATES.IDLE);
            }
        };
        return Actions.sequence(Actions.run(r1), Actions.moveTo(destiny.x, destiny.y, time, Interpolation.pow2Out), Actions.run(r2));
    }



